// Note: This file depends on the version of code generated by Verilator. Adjust promptly if parsing issues arise.

#include "parser/verilator_root.hpp"

namespace picker { namespace parser {

    // 去除前后空白字符
    std::string trim(const std::string &s)
    {
        auto start = s.begin();
        while (start != s.end() && isspace(*start)) start++;
        auto end = s.end();
        do {
            end--;
        } while (distance(start, end) > 0 && isspace(*end));
        return std::string(start, end + 1);
    }

    void outputYAML(const std::vector<cpp_variableInfo> &vars, const std::string &fileName)
    {
        std::ostream *out = &std::cout;
        std::ofstream file;
        if (!fileName.empty()) {
            std::string absFPath = std::filesystem::absolute(fileName);
            file.open(absFPath);
            if (!file.is_open()) {
                PK_FATAL("Failed to open file: %s", absFPath.c_str());
                return;
            }
            out = &file;
        }
        *out << "variables:\n";
        for (const auto &var : vars) {
            *out << "  - name: " << var.name << "\n"
                 << "    type: " << var.type << "\n"
                 << "    width: " << var.width << "\n";
            if (var.array_size > 0) { *out << "    array_size: " << var.array_size << "\n"; }
        }
        *out << "  - total: " << vars.size() << "\n";
        out->flush();
        if (file.is_open()) { file.close(); }
    }

namespace verilator {
    std::vector<std::string> readVarDeclarations(const std::string &filename)
    {
        std::vector<std::string> declarations;
        std::ifstream file(filename);
        std::string line;
        // XXX.h -> XXX
        std::string class_name = filename.substr(0, filename.find_last_of('.')) + "(";
        int structDepth = 0, no_struct = -1;

        // 1. We are scanning for variable declarations inside struct blocks.
        // Increase structDepth on "struct {" and decrease it on "};".
        // There might be multiple struct blocks or nested struct blocks.
        // 2. Otherwise, there is no struct block and we are scanning for Data declarations.
        // Start with *Data Declaration and end with class_name::class_name().
        while (getline(file, line)) {
            line = trim(line);
            if (line.empty()) continue;

            if (line.find("struct {") != std::string::npos) {
                structDepth++;
                no_struct = 0;
                continue;
            } // 1

            if (line.find("Data") != std::string::npos && no_struct == -1) {
                no_struct = 1;
                continue;
            } // 2

            if (structDepth > 0 && line.find("};") != std::string::npos) {
                structDepth--;
                continue;
            } // 1

            if (line.find(class_name) != std::string::npos) {
                no_struct = -1;
                break;
            } // 2

            if (structDepth > 0 || no_struct > 0) {
                size_t commentPos = line.find("//");
                if (commentPos != std::string::npos) { line = line.substr(0, commentPos); }
                line = trim(line);
                if (!line.empty()) { declarations.push_back(line); }
            }
        }
        return declarations;
    }

    cpp_variableInfo parseType(const std::string &typeStr)
    {
        cpp_variableInfo info;
        std::smatch match;

        // Match VlUnpacked type
        if (std::regex_match(typeStr, match, std::regex(R"(^VlUnpacked<(.+),\s*(\d+)>$)"))) {
            std::string innerType = trim(match[1]);
            info.array_size       = stoi(match[2]);
            cpp_variableInfo inner    = parseType(innerType);
            info.type             = inner.type;
            info.width            = inner.width;
        }
        // Match VlWide type
        else if (std::regex_match(typeStr, match, std::regex(R"(^VlWide<(\d+)>/\*(\d+:\d+)\*/$)"))) {
            info.type         = "VlWide<" + match[1].str() + ">";
            std::string range = match[2];
            size_t colon      = range.find(':');
            int high          = stoi(range.substr(0, colon));
            int low           = stoi(range.substr(colon + 1));
            info.width        = high - low + 1;
        }
        // Match Basic type (only CData/SData/QData/IData/WData)
        else if (std::regex_match(typeStr, match, std::regex(R"(^(CData|SData|QData|IData|WData)/\*(\d+:\d+)\*/$)"))) {
            info.type         = match[1];
            std::string range = match[2];
            size_t colon      = range.find(':');
            int high          = stoi(range.substr(0, colon));
            int low           = stoi(range.substr(colon + 1));
            info.width        = high - low + 1;
        }

        if (info.array_size > 0) {
            PK_DEBUG("type: %s, width: %d, array_size: %d", info.type.c_str(), info.width, info.array_size);
        } else {
            PK_DEBUG("type: %s, width: %d", info.type.c_str(), info.width);
        }

        return info;
    }

    std::vector<cpp_variableInfo> processDeclarations(const std::vector<std::string> &declarations)
    {
        std::vector<cpp_variableInfo> vars;
        std::regex varRegex(R"(^(.+[^\s])\s+([a-zA-Z_]\w*);$)");

        for (const auto &decl : declarations) {
            std::smatch match;
            if (std::regex_match(decl, match, varRegex)) {
                std::string typeStr = trim(match[1]);
                std::string varName = trim(match[2]);

                PK_DEBUG("typeStr: %s, varName: %s", typeStr.c_str(), varName.c_str());
                cpp_variableInfo info = parseType(typeStr);
                info.name         = varName;
                if (!info.type.empty()) vars.push_back(info);
            }
        }
        return vars;
    }

}}} // namespace picker::parser::verilator