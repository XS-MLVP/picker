# File       : {{package_name}}_xagent.py
# Author     : automatically generated by picker
# Date       : {{date_now}}
# Description: Unified agent for UVM-Python communication
# Version    : {{version}}

from typing import Optional, Callable, Dict, Type, List, NamedTuple


class FieldMeta(NamedTuple):
    """Metadata for a transaction field."""
    name: str
    byte_offset: int
    byte_count: int
    bit_count: int

try:
    from . import tlm_pbsb as u
    from . import xspcomm as xsp
except ImportError:
    import tlm_pbsb as u
    import xspcomm as xsp


class BaseTransaction:
    """Base class for UVM transactions with common serialization logic."""

    _fields_metadata: List[FieldMeta] = []
    _byte_stream_count: int = 0
    _transaction_type: str = "BaseTransaction"

    def __init__(self, msg: Optional[bytes] = None) -> None:
        self._init_fields()
        if msg is not None:
            self.from_msg(msg)

    def _init_fields(self) -> None:
        raise NotImplementedError(f"{self.__class__.__name__} must implement _init_fields()")

    # ============================================================================
    # Serialization/Deserialization Core Methods
    # ============================================================================

    @staticmethod
    def _serialize_field(value: int, byte_count: int) -> bytes:
        """
        Serialize a single field to bytes.

        Args:
            value: Integer value to serialize
            byte_count: Number of bytes for this field

        Returns:
            Serialized bytes in big-endian format
        """
        if byte_count == 1:
            return bytes([value & 0xFF])
        return value.to_bytes(byte_count, byteorder='big')

    @staticmethod
    def _deserialize_field(data: bytes, offset: int, byte_count: int) -> int:
        """
        Deserialize a single field from bytes.

        Args:
            data: Byte array containing serialized data
            offset: Starting position in the byte array
            byte_count: Number of bytes for this field

        Returns:
            Deserialized integer value
        """
        if byte_count == 1:
            return data[offset]
        return int.from_bytes(data[offset:offset + byte_count], byteorder='big')

    def from_msg(self, msg: bytes) -> None:
        """Deserialize from UVM message."""
        if len(msg) < self._byte_stream_count:
            raise ValueError(
                f"Invalid message length for {self._transaction_type}: "
                f"expected {self._byte_stream_count} bytes, got {len(msg)} bytes"
            )

        for field in self._fields_metadata:
            field_value = self._deserialize_field(msg, field.byte_offset, field.byte_count)
            getattr(self, field.name).value = field_value

    def to_bytes(self) -> bytes:
        """Serialize to byte stream."""
        result = bytearray(self._byte_stream_count)

        for field in self._fields_metadata:
            value = getattr(self, field.name).value
            field_bytes = self._serialize_field(value, field.byte_count)
            result[field.byte_offset:field.byte_offset + field.byte_count] = field_bytes

        return bytes(result)

    def copy_from_dict(self, values: Dict[str, int]) -> None:
        """
        Copy values from a dictionary to transaction fields.

        Args:
            values: Dictionary mapping field names to values

        Example:
            tr.copy_from_dict({'a': 10, 'b': 20})
        """
        for field in self._fields_metadata:
            if field.name in values:
                getattr(self, field.name).value = values[field.name]

    def to_dict(self) -> Dict[str, int]:
        """
        Export transaction fields as a dictionary.

        Returns:
            Dictionary mapping field names to values
        """
        return {field.name: getattr(self, field.name).value for field in self._fields_metadata}

    def __repr__(self) -> str:
        fields = ', '.join([f"{field.name}={getattr(self, field.name).value}" for field in self._fields_metadata])
        return f"{self._transaction_type}({fields})"


{% for trans in transactions -%}
class {{trans.name}}(BaseTransaction):
    """{{trans.name}} transaction ({{trans.byte_stream_count}} bytes)"""

    _transaction_type = "{{trans.name}}"
    _byte_stream_count = {{trans.byte_stream_count}}
    _fields_metadata = [
        {% for data in trans.variables -%}
        FieldMeta("{{data.name}}", {{data.byte_offset}}, {{data.byte_count}}, {{data.bit_count}}),
        {% endfor -%}
    ]

    def _init_fields(self) -> None:
        {% for data in trans.variables %}
        self.{{data.name}} = xsp.XData({{data.bit_count}})
        {% endfor %}


{% endfor %}
class Agent:
    """Unified agent managing transaction types and TLM communication."""

    def __init__(self, monitor_callback: Optional[Callable[[str, BaseTransaction], None]] = None, auto_register: bool = True) -> None:
        u.tlm_vcs_init("_tlm_pbsb.so", "-no_save")
        self._send_ports: Dict[str, any] = {}
        self._receive_ports: Dict[str, any] = {}
        self._transaction_registry: Dict[str, Type[BaseTransaction]] = {}
        self._monitor_callback = monitor_callback

        # Clock management
        self._clock_enabled: bool = False
        self._cycle_count: int = 0
        self._posedge_callbacks: List[Callable[[int], None]] = []
        self._negedge_callbacks: List[Callable[[int], None]] = []

        # Auto-register all transaction types with default ports
        if auto_register:
            {% for trans in transactions -%}
            self.register_transaction({{trans.name}}, send_port="{{trans.name}}", receive_port="{{trans.name}}")
            {% endfor %}

    def register_transaction(self, trans_class: Type[BaseTransaction],
                            send_port: Optional[str] = None,
                            receive_port: Optional[str] = None) -> None:
        """Register transaction type with communication ports."""
        trans_type = trans_class._transaction_type
        self._transaction_registry[trans_type] = trans_class

        if send_port:
            port = u.TLMPub(send_port)
            port.Connect()
            self._send_ports[trans_type] = port

        if receive_port:
            if not self._monitor_callback:
                print(f"Warning: receive_port '{receive_port}' specified but no monitor_callback provided.")
            else:
                def make_callback(t_type, t_class):
                    return lambda msg: self._monitor_callback(t_type, t_class(msg.as_bytes()))

                port = u.TLMSub(receive_port, make_callback(trans_type, trans_class))
                port.Connect()
                self._receive_ports[trans_type] = port

    def drive(self, transaction: BaseTransaction) -> None:
        """Drive transaction to UVM with automatic port routing."""
        trans_type = transaction._transaction_type

        if trans_type not in self._send_ports:
            raise ValueError(f"No send port for '{trans_type}'. Call register_transaction() first.")

        byte_stream = transaction.to_bytes()
        uvm_message = u.tlm_msg()
        uvm_message.from_bytes(byte_stream)
        self._send_ports[trans_type].SendMsg(uvm_message)

    def run(self, cycles: int, count_cycles: bool = True) -> None:
        """
        Drive UVM clock cycles and execute callbacks if clock is enabled.

        Args:
            cycles: Number of UVM steps to execute
            count_cycles: Whether to increment cycle counter (default: True)
        """
        for _ in range(cycles):
            u.step(1)
            if self._clock_enabled and count_cycles:
                self._cycle_count += 1
                # Execute posedge callbacks
                for callback in self._posedge_callbacks:
                    callback(self._cycle_count)

    def InitClock(self, domain: str = "default", frequency: Optional[float] = None) -> None:
        """
        Initialize clock tracking and enable callbacks.

        Args:
            domain: Clock domain name for documentation (default: "default")
            frequency: Optional clock frequency in Hz

        Example:
            agent.InitClock()
            agent.InitClock(domain="sys_clk", frequency=100e6)
        """
        self._clock_enabled = True
        self._cycle_count = 0
        freq_info = f", frequency: {frequency/1e6:.2f} MHz" if frequency else ""
        print(f"[Agent.InitClock] Clock tracking initialized (domain: {domain}{freq_info})")

    def StepRis(self, callback: Callable[[int], None]) -> None:
        """
        Register callback for clock rising edge.

        Args:
            callback: Function that takes cycle number as argument

        Example:
            def on_posedge(cycle):
                print(f"Cycle {cycle}")

            agent.StepRis(on_posedge)
        """
        self._posedge_callbacks.append(callback)

    def StepFal(self, callback: Callable[[int], None]) -> None:
        """
        Register callback for clock falling edge.

        Args:
            callback: Function that takes cycle number as argument

        Note: Currently falling edge callbacks are not triggered in Pack mode.
        """
        self._negedge_callbacks.append(callback)
        print("[Agent.StepFal] Warning: Falling edge callbacks are not supported in Pack mode")

    def GetCycleCount(self) -> int:
        """
        Get current simulation cycle count.

        Returns:
            Number of cycles executed since InitClock
        """
        return self._cycle_count
