# File       : xagent.py
# Author     : automatically generated by picker
# Date       : {{datenow}}
# Description: This is a template generated by picker. Use this, you can achieve 
#              communication between UVM and Python.
# Version    : {{version}}
import tlm_pbsb as u
import xspcomm as xsp
class Agent:
    """
    The Env is used to initialize UVM project and build/connect port with UVM
    """

    def __init__(self,send_port = "",receive_port = "", receive_function = None):
        """
        Initialize a TLM port connected to UVM using the port name and a function to process the received sequence
        """

        u.tlm_vcs_init("_tlm_pbsb.so", "-no_save")
        if send_port != "":
            self.send_port = u.TLMPub(send_port)
            self.send_port.Connect()
        if  receive_port != "" and receive_function != None:
            self.receive_port = u.TLMSub(receive_port, lambda a: receive_function(a.as_bytes()))
            self.receive_port.Connect()

    def run(self, nums):
        """
        drive uvm clock
        """ 
        for i in range(nums):
            u.step(1)

class {{className}}:
    """
    Define UVM sequence in Python
    this class is used to convert message received from UVM to python class and send sequence to UVM
    """

    def __init__(self, msg = None):
        {%for data in variables -%}
        self.{{data.name}} = xsp.XData({{data.bit_count}})
        {%endfor -%}
        if msg != None:
            self.from_msg(msg)

    
    def from_msg(self,msg):
        """
        convert message received from UVM to python sequence
        """

        def convert_msg(self, {%for data in variables -%} {{data.name}}{%if not loop.is_last -%}, {%endif -%}{%endfor -%}):
            {%for data in variables -%}
            {%if data.nums == 1 -%}
            self.{{data.name}}.value = {{data.name}}
            {%else -%}
            self.{{data.name}}.value = int.from_bytes({{data.name}},byteorder = 'big')
            {%endif -%}
            {%endfor %}
        
        {%for data in variables -%}
        {%if data.macro == 1 -%}
        {{data.macro_name}} = {{data.bit_count}}
        {%endif -%}
        {%endfor -%}
        {% set counter =  0 -%}
        #convert_msg(self, {% for data in variables -%}msg[{{ data.start_index }},{{ data.end_index }}]{% if not loop.is_last -%}, {% endif -%}{% endfor %})
        convert_msg(self, {%for data in variables -%}{%if data.nums == 1 -%}msg[{{counter}}],{% set counter = counter + 1 -%}{%else -%}msg[{{counter}}:{%for i in range(data.nums) -%}{% set counter = counter + 1 -%} {%endfor -%}{{counter}}]{%if not loop.is_last -%},{%endif -%}{%endif -%}{%endfor -%})
    
    def send(self,env):
        """
        convert sequence to byte stream then send it to UVM
        """
        
        def add_zero(bytes):
            padding = 8 - len(bytes) % 8
            if(padding != 8):
                bytes = '0'*padding + bytes
            return bytes
        {%for data in variables -%}
        {{data.name}} = add_zero(bin(self.{{data.name}}.value)[2:].zfill({{data.bit_count}}))
        {%endfor -%}
        byte_str = {%for data in variables%} {{data.name}} {%if not loop.is_last -%}+ {%endif -%}{%endfor%}
        byte_list = [int(byte_str[i:i+8],2).to_bytes(1,'big') for i in range(0,len(byte_str),8)]
        byte_stream = b''.join(byte_list)
        uvm_message = u.tlm_msg()
        uvm_message.from_bytes(byte_stream)
        env.send_port.SendMsg(uvm_message)

class {{className}}_list:
    def __init__(self,message):
        self.sequence_list = []
        if(len(message) != 0):
            self.to_list(message)
    
    def to_list(self, message):
        index = 0
        chunk_size = {{byte_stream_count}}
        while index < len(message):
            chunk = message[index:index+chunk_size]
            index+=chunk_size
            tr = {{className}}(chunk)
            self.sequence_list.append(tr)
