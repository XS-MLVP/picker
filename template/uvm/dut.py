# File       : __init__.py
# Author     : automatically generated by picker
# Date       : {{date_now}}
# Description: Python package initialization for {{package_name}}
# Version    : {{version}}

"""
{{package_name}} Python Package

UVM transaction-based communication package.
"""

__version__ = "{{version}}"

{% if generate_dut -%}
# ============================================================================
# DUT Mode: Integrated __init__.py with DUT implementation
# ============================================================================

from typing import Optional, Callable, Dict, Type, List
import struct
import os
import sys
import subprocess

# Handle LD_PRELOAD for _tlm_pbsb.so (required for static TLS)
if '_LD_PRELOAD_HANDLED' not in os.environ:
    dut_dir = os.path.dirname(os.path.abspath(__file__))
    so_path = os.path.join(dut_dir, '_tlm_pbsb.so')

    # Setup environment
    env = os.environ.copy()
    env['LD_PRELOAD'] = so_path if not env.get('LD_PRELOAD') else f"{so_path}:{env['LD_PRELOAD']}"
    env['_LD_PRELOAD_HANDLED'] = '1'

    # Convert relative file paths to absolute for pytest arguments
    def fix_path(arg):
        if arg.startswith('-') or not ('::' in arg or os.path.exists(arg)):
            return arg
        if '::' in arg:
            path, test = arg.split('::', 1)
            return f"{os.path.abspath(path)}::{test}" if os.path.exists(path) else arg
        return os.path.abspath(arg)

    new_args = [sys.argv[0]] + [fix_path(arg) for arg in sys.argv[1:]]

    # Check if we need to change directory to Adder (for VCS database files)
    if os.path.abspath(os.getcwd()) != dut_dir:
        # Run subprocess in Adder directory
        result = subprocess.run([sys.executable] + new_args, env=env, cwd=dut_dir,
                               capture_output=True, text=True)

        # Handle VCS cleanup crashes: if tests passed but process crashed (SIGABRT), treat as success
        output = result.stdout + result.stderr
        success = result.returncode < 0 and ' passed' in output and 'PASSED' in output

        print(result.stdout, end='')
        print(result.stderr, end='', file=sys.stderr)
        os._exit(0 if success else max(1, result.returncode))
    else:
        # Already in correct directory, just restart with LD_PRELOAD
        os.execve(sys.executable, [sys.executable] + sys.argv, env)
# Handle LD_PRELOAD for _tlm_pbsb.so
# if '_LD_PRELOAD_HANDLED' not in os.environ:
#     so_path = os.path.join(os.path.dirname(__file__), '_tlm_pbsb.so')
#     env = os.environ.copy()
#     env['LD_PRELOAD'] = so_path + ':' + env.get('LD_PRELOAD', '') if env.get('LD_PRELOAD') else so_path
#     env['_LD_PRELOAD_HANDLED'] = '1'
    
#     # Restart from Adder directory
#     dut_dir = os.path.dirname(__file__)
#     script_path = os.path.abspath(sys.argv[0])
#     subprocess.run([sys.executable, script_path] + sys.argv[1:], env=env, cwd=dut_dir)
#     sys.exit(0)

try:
    from . import tlm_pbsb as u
    from . import xspcomm as xsp
except ImportError:
    import tlm_pbsb as u
    import xspcomm as xsp


# ==================== Agent and Transaction Classes ====================
# Import from xagent module
from .xagent import Agent, BaseTransaction{% for trans in transactions %}, {{trans.name}}{% endfor %}


# ==================== DUT Implementation ====================

class _PinWrapper:
    """Wrapper to provide dut.pin.value access instead of dut.pin.xdata.value"""
    def __init__(self, xpin: xsp.XPin):
        self._xpin = xpin

    @property
    def value(self):
        return self._xpin.xdata.value

    @value.setter
    def value(self, val):
        self._xpin.xdata.value = val

    @property
    def xpin(self):
        return self._xpin

    @property
    def xdata(self):
        return self._xpin.xdata

    @property
    def event(self):
        return self._xpin.event  

class DUT{{package_name}}:
    """
    DUT abstraction for {{package_name}} with pin-level interface.

    Pins:
    {% for data in variables -%}
    - {{data.name}}: {{data.bit_count}}-bit signal
    {% endfor -%}

    Example:
        >>> dut = DUT{{package_name}}()
        {%- for data in variables %}
        {%- if loop.index == 1 %}
        >>> dut.{{data.name}}.value = 10
        {%- endif %}
        {%- endfor %}
        >>> dut.Step(1)
    """

    def __init__(self, **kwargs):
        """Initialize DUT with Agent and xspcomm infrastructure."""
        self._event = xsp.Event()
        self._xports: Dict[str, xsp.XPort] = {}
        self._user_callback: Optional[Callable[['DUT{{package_name}}'], None]] = None
        self._xpins = {}
        self._callback_pending = False

        # Monitor feedback extra cycles (configurable)
        self._monitor_extra_cycles: int = kwargs.get('monitor_extra_cycles', 1)

        # Initialize XPins and XPorts per transaction
        {% for trans in transactions -%}
        # Transaction: {{trans.name}}
        self._xports['{{trans.name}}'] = xsp.XPort()
        {% for data in trans.variables -%}
        self._xpins['{{data.name}}'] = xsp.XPin(xsp.XData({{data.bit_count}}), self._event)
        self._xpins['{{data.name}}'].xdata.AsImmWrite()
        self._xports['{{trans.name}}'].Add("{{data.name}}", self._xpins['{{data.name}}'].xdata)
        {% endfor -%}

        {% endfor -%}
        # Create pin accessors
        {% for data in variables -%}
        self.{{data.name}} = _PinWrapper(self._xpins['{{data.name}}'])
        {% endfor -%}

        # Monitor callback
        def _monitor_callback(trans_type: str, trans_obj):
            """Internal callback for monitor updates."""
            try:
                # Update pins from received transaction
                {% for trans in transactions %}
                if trans_type == '{{trans.name}}':   
                    {% for data in trans.variables -%}
                    self._xpins['{{data.name}}'].xdata.value = trans_obj.{{data.name}}.value
                    {% endfor -%}                            
                {% endfor %}
                self._callback_pending = True
            except Exception as e:
                print(f"Monitor callback error: {e}")

        # Initialize unified Agent (disable auto_register, we'll register manually)
        self.agent = Agent(monitor_callback=_monitor_callback, auto_register=False)

        # Register all transaction types
        {% for trans in transactions -%}
        send_port = kwargs.get('send_port_{{trans.name}}', '{{trans.name}}')
        receive_port = kwargs.get('receive_port_{{trans.name}}', '{{trans.name}}')
        self.agent.register_transaction({{trans.name}}, send_port=send_port, receive_port=receive_port)
        {% endfor %}
        self.dut = self

        class _Clock:
            def __init__(self, agent): self.agent = agent
            @property
            def clk(self): return self.agent._cycle_count
        self.xclock = _Clock(self.agent)

    def Step(self, cycles: int = 1):
        """
        Advance simulation by specified cycles.
        1. Send current pin values as transactions
        2. Run simulation
        3. Update pins from monitor
        4. Execute clock callbacks (after monitor update)
        """
        for i in range(cycles):
            # Create and drive transactions
            {% for trans in transactions -%}
            tr = {{trans.name}}()
            {% for data in trans.variables -%}
            tr.{{data.name}}.value = self._xpins['{{data.name}}'].xdata.value
            {% endfor -%}
            self.agent.drive(tr)
            {% endfor -%}
            self._callback_pending = False

            # Run 1 cycle WITHOUT triggering callbacks yet
            self.agent.run(1, count_cycles=False)

            # Run extra cycles for monitor feedback without counting
            self.agent.run(self._monitor_extra_cycles, count_cycles=False)

            # Wait for monitor callback (without counting cycles)
            wait_count = 0
            while not self._callback_pending and wait_count < 10:
                self.agent.run(1, count_cycles=False)
                wait_count += 1

            # Trigger user callback
            if self._callback_pending and self._user_callback:
                self._user_callback(self)
                self._callback_pending = False

            # NOW increment cycle and trigger callbacks after monitor update
            if self.agent._clock_enabled:
                self.agent._cycle_count += 1
                for callback in self.agent._posedge_callbacks:
                    callback(self.agent._cycle_count)

    def SetUpdateCallback(self, callback: Optional[Callable[['DUT{{package_name}}'], None]]):
        """Register callback after monitor updates."""
        self._user_callback = callback

    def SetZero(self):
        """Set all pins to zero."""
        {% for data in variables -%}
        self._xpins['{{data.name}}'].xdata.value = 0
        {% endfor %}

    def InitClock(self, clock_pin: Optional[str] = None, domain: str = "default", frequency: Optional[float] = None):
        """
        Initialize clock tracking and management.

        Args:
            clock_pin: Name of the clock pin (optional, for validation only)
                      If None, clock tracking works without pin validation
            domain: Clock domain name for documentation (default: "default")
            frequency: Optional clock frequency in Hz

        Example:
            dut.InitClock()  # Simple cycle counting
            dut.InitClock("clk")  # Validate clock pin exists
            dut.InitClock("clk", domain="sys_clk", frequency=100e6)
        """
        if clock_pin is not None and clock_pin not in self._xpins:
            raise ValueError(f"Clock pin '{clock_pin}' not found. Available pins: {list(self._xpins.keys())}")

        # Delegate to Agent
        self.agent.InitClock(domain=domain, frequency=frequency)

    def StepRis(self, callback: Callable[[int], None]):
        """
        Register callback for clock rising edge.

        Args:
            callback: Function that takes cycle number as argument

        Example:
            def on_posedge(cycle):
                print(f"Cycle {cycle}: value = {dut.pin.value}")

            dut.StepRis(on_posedge)
        """
        # Delegate to Agent
        self.agent.StepRis(callback)

    def StepFal(self, callback: Callable[[int], None]):
        """
        Register callback for clock falling edge.

        Args:
            callback: Function that takes cycle number as argument

        Note: Currently falling edge callbacks are not triggered in Pack mode
              as the clock is managed by SystemVerilog testbench.
        """
        # Delegate to Agent
        self.agent.StepFal(callback)

    def GetCycleCount(self) -> int:
        """
        Get current simulation cycle count.

        Returns:
            Number of cycles executed since InitClock

        Example:
            cycle = dut.GetCycleCount()
            print(f"Current cycle: {cycle}")
        """
        # Delegate to Agent
        return self.agent.GetCycleCount()

    def Finish(self):
        """
        Finish simulation and cleanup.

        Example:
            dut.Finish()
        """
        print(f"[Finish] Simulation completed. Total cycles: {self.agent.GetCycleCount()}")

    def GetAgent(self):
        """Get underlying Agent object."""
        return self.agent

    def __repr__(self):
        fields = []
        {% for data in variables -%}
        fields.append(f"{{data.name}}={self._xpins['{{data.name}}'].xdata.value}")
        {% endfor -%}
        if self.agent._clock_enabled:
            fields.append(f"cycle={self.agent.GetCycleCount()}")
        return f"DUT{{package_name}}({', '.join(fields)})"

    def RefreshComb(self):
        self.InitClock()
        print("this function is not supported in pack mode")

    def PauseWaveformDump(self):
        print("this function is not supported in pack mode")

    def ResumeWaveformDump(self):
        print("this function is not supported in pack mode")


# Public API for DUT mode
__all__ = [
    "Agent",
    "BaseTransaction",
    "DUT{{package_name}}",
    {% for trans in transactions -%}
    "{{trans.name}}",
    {% endfor -%}
    "u",
    "xsp",
]

{% else -%}
# ============================================================================
# Agent Mode: Standard modular imports
# ============================================================================

try:
    from . import tlm_pbsb as u
    from . import xspcomm as xsp
    from .xagent import Agent, BaseTransaction{% for trans in transactions %}, {{trans.name}}{% endfor %}
except ImportError as e:
    import warnings
    warnings.warn(f"Could not import components: {e}")
    raise

# Public API for Agent mode
__all__ = [
    "Agent",
    "BaseTransaction",
    {% for trans in transactions -%}
    "{{trans.name}}",
    {% endfor -%}
    "u",
    "xsp",
]

{% endif -%}
