//==============================================================================//
// File       : example.sv
// Author     : automatically generated by picker
// Date       : {{date_now}}
// Description: UVM testbench for {{package_name}} example
//              Supports bidirectional communication (Python ←→ UVM)
{% if generate_dut -%}
//              - Driver receives transactions from Python and drives DUT
//              - Monitor samples DUT outputs and sends back to Python
{% else -%}
//              - Echo-back mode for testing Python-UVM communication
{% endif -%}
// Version    : {{version}}
//==============================================================================//
import uvm_pkg::*;
import uvmc_pkg::*;

// Include common utility package before agents
`include "{{package_name}}/utils_pkg.sv"

// include transaction definitions and agents
{% for trans in transactions -%}
{% if generate_dut -%}
`include "{{trans.filepath}}"
{% else -%}
`include "../{{trans.filepath}}"
{% endif -%}
`include "{{package_name}}/xagent.sv"
{% endfor -%}

{% if generate_dut -%}
// Interface for DUT signals (auto-generated from transactions)
interface dut_interface(input clk, input rst_n);
{% for trans in transactions -%}
{% for var in trans.variables -%}
{% if var.bit_count == 1 -%}
    logic {{var.name}};
{% else -%}
    logic [{{var.bit_count - 1}}:0] {{var.name}};
{% endif -%}
{% endfor -%}
{% endfor -%}
endinterface
{% else -%}
// Echo-back mode: minimal interface for communication test
interface example_interface(input clk, input rst_n);
    // No DUT signals needed for echo-back mode
endinterface
{% endif -%}

{% if generate_dut -%}
// =============================================================================
// DUT Mode: UVM-compliant Driver and Monitor
// =============================================================================

{% for trans in transactions -%}
// Driver for {{trans.name}} - receives from Python and drives DUT inputs
class {{trans.name}}_driver extends {{trans.name}}_xdriver;
    `uvm_component_utils({{trans.name}}_driver);

    virtual dut_interface vif;
    int transaction_count;

    function new (string name = "{{trans.name}}_driver", uvm_component parent = null);
        super.new(name, parent);
        transaction_count = 0;
    endfunction

    virtual function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        if (!uvm_config_db#(virtual dut_interface)::get(this, "", "vif", vif))
            `uvm_fatal("{{trans.name}}_driver", "Virtual interface not found")
    endfunction

    virtual task sequence_receive({{trans.class_name}} tr);
        transaction_count++;
        `uvm_info("{{trans.name}}_driver",
                  $sformatf("Received transaction #%0d from Python:\n%s", transaction_count, tr.sprint()),
                  UVM_LOW)

        // Drive DUT inputs through VIF
{% for var in trans.variables -%}
        vif.{{var.name}} = tr.{{var.name}};
{% endfor -%}

        `uvm_info("{{trans.name}}_driver", "DUT inputs driven", UVM_MEDIUM)
    endtask

    function void report_phase(uvm_phase phase);
        super.report_phase(phase);
        `uvm_info("{{trans.name}}_driver",
                  $sformatf("Total transactions received: %0d", transaction_count),
                  UVM_LOW)
    endfunction
endclass

// Monitor for {{trans.name}} - independently samples DUT outputs
class {{trans.name}}_monitor extends {{trans.name}}_xmonitor;
    `uvm_component_utils({{trans.name}}_monitor);

    virtual dut_interface vif;
    {{trans.class_name}} prev_tr;

    function new (string name = "{{trans.name}}_monitor", uvm_component parent = null);
        super.new(name, parent);
    endfunction

    virtual function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        if (!uvm_config_db#(virtual dut_interface)::get(this, "", "vif", vif))
            `uvm_fatal("{{trans.name}}_monitor", "Virtual interface not found")
        prev_tr = {{trans.class_name}}::type_id::create("prev_tr");
    endfunction

    virtual task run_phase(uvm_phase phase);
        {{trans.class_name}} tr;

        forever begin
            // Default: Sequential logic sampling (clock edge)
            @(posedge vif.clk);

            // Uncomment for combinational logic sampling:
            // @(vif signal changes);
            // #1step;  // Wait for combinational logic to settle

            // Sample all signals from VIF
            tr = {{trans.class_name}}::type_id::create("tr");
{% for var in trans.variables -%}
            tr.{{var.name}} = vif.{{var.name}};
{% endfor -%}

            // Send sampled transaction back to Python
            sequence_send(tr);
            prev_tr.copy(tr);

            `uvm_info("{{trans.name}}_monitor",
                      $sformatf("Sampled DUT signals and sent to Python:\n%s", tr.sprint()),
                      UVM_MEDIUM)
        end
    endtask
endclass

{% endfor -%}
{% else -%}
// =============================================================================
// Echo-back Mode: Test Python-UVM communication without DUT
// =============================================================================

{% for trans in transactions -%}
// Driver for {{trans.name}} - receives from Python and forwards to subscriber
class {{trans.name}}_driver extends {{trans.name}}_xdriver;
    `uvm_component_utils({{trans.name}}_driver);

    int transaction_count;
    uvm_analysis_port #({{trans.class_name}}) ap;

    function new (string name = "{{trans.name}}_driver", uvm_component parent = null);
        super.new(name, parent);
        transaction_count = 0;
        ap = new("ap", this);
    endfunction

    virtual function void build_phase(uvm_phase phase);
        super.build_phase(phase);
    endfunction

    virtual task sequence_receive({{trans.class_name}} tr);
        {{trans.class_name}} tr_clone;
        transaction_count++;
        `uvm_info("{{trans.name}}_driver",
                  $sformatf("Received transaction #%0d from Python:\n%s", transaction_count, tr.sprint()),
                  UVM_LOW)

        // Clone and write to analysis port for echo back
        if($cast(tr_clone, tr.clone())) begin
            ap.write(tr_clone);
        end else begin
            `uvm_error("{{trans.name}}_driver", "Failed to clone transaction")
        end
    endtask

    function void report_phase(uvm_phase phase);
        super.report_phase(phase);
        `uvm_info("{{trans.name}}_driver",
                  $sformatf("Total transactions received: %0d", transaction_count),
                  UVM_LOW)
    endfunction
endclass

// Subscriber for {{trans.name}} - echoes transactions back to Python
class {{trans.name}}_echo_subscriber extends uvm_component;
    `uvm_component_utils({{trans.name}}_echo_subscriber)

    uvm_analysis_export #({{trans.class_name}}) analysis_export;
    uvm_tlm_analysis_fifo #({{trans.class_name}}) fifo;
    {{trans.name}}_xmonitor mon_handle;

    function new(string name = "{{trans.name}}_echo_subscriber", uvm_component parent = null);
        super.new(name, parent);
        analysis_export = new("analysis_export", this);
        fifo = new("fifo", this);
    endfunction

    function void connect_phase(uvm_phase phase);
        super.connect_phase(phase);
        analysis_export.connect(fifo.analysis_export);
    endfunction

    virtual task run_phase(uvm_phase phase);
        {{trans.class_name}} tr;
        forever begin
            fifo.get(tr);
            if (mon_handle != null) begin
                mon_handle.sequence_send(tr);
                `uvm_info("{{trans.name}}_echo_subscriber",
                          $sformatf("Echoed back to Python:\n%s", tr.sprint()),
                          UVM_MEDIUM)
            end
        end
    endtask
endclass

{% endfor -%}
{% endif -%}

// =============================================================================
// Environment
// =============================================================================

class example_env extends uvm_env;
    `uvm_component_utils(example_env)

{% for trans in transactions -%}
    {{trans.name}}_xagent            {{trans.name}}_agent;
    {{trans.name}}_xagent_config     {{trans.name}}_config;
{% if generate_dut -%}
    {{trans.name}}_driver            {{trans.name}}_drv;
    {{trans.name}}_monitor           {{trans.name}}_mon;
{% else -%}
    {{trans.name}}_driver            {{trans.name}}_drv;
    {{trans.name}}_echo_subscriber   {{trans.name}}_echo_sub;
{% endif -%}
{% endfor -%}
{% if generate_dut -%}
    virtual dut_interface vif;
{% else -%}
    virtual example_interface vif;
{% endif -%}

    function new (string name = "example_env", uvm_component parent = null);
        super.new(name, parent);

        // Configure agents with factory overrides
{% for trans in transactions -%}
        {{trans.name}}_config = new("{{trans.name}}_config");
        {{trans.name}}_config.is_active = UVM_ACTIVE;
        uvm_config_db#({{trans.name}}_xagent_config)::set(this, "{{trans.name}}_agent", "{{trans.name}}_xagent_config", {{trans.name}}_config);

        // Override default driver with custom implementation
        set_type_override_by_type({{trans.name}}_xdriver::get_type(), {{trans.name}}_driver::get_type());
{% if generate_dut -%}
        // Override default monitor with custom implementation
        set_type_override_by_type({{trans.name}}_xmonitor::get_type(), {{trans.name}}_monitor::get_type());
{% endif -%}
{% endfor -%}
    endfunction

    function void build_phase(uvm_phase phase);
        super.build_phase(phase);

        // Build agents
{% for trans in transactions -%}
        {{trans.name}}_agent = {{trans.name}}_xagent::type_id::create("{{trans.name}}_agent", this);
{% if not generate_dut -%}
        {{trans.name}}_echo_sub = {{trans.name}}_echo_subscriber::type_id::create("{{trans.name}}_echo_sub", this);
{% endif -%}
{% endfor -%}

        // Get virtual interface
{% if generate_dut -%}
        if(!uvm_config_db#(virtual dut_interface)::get(this, "", "vif", vif))
            `uvm_fatal("example_env", "Virtual interface must be set for vif")
{% else -%}
        if(!uvm_config_db#(virtual example_interface)::get(this, "", "vif", vif))
            `uvm_fatal("example_env", "Virtual interface must be set for vif")
{% endif -%}
    endfunction

    function void connect_phase(uvm_phase phase);
        super.connect_phase(phase);

{% if not generate_dut -%}
        // Echo-back mode: connect driver to subscriber to monitor
{% for trans in transactions -%}
        if ({{trans.name}}_agent.{{trans.name}}_xdrv != null && {{trans.name}}_agent.{{trans.name}}_xmon != null) begin
            if ($cast({{trans.name}}_drv, {{trans.name}}_agent.{{trans.name}}_xdrv)) begin
                {{trans.name}}_drv.ap.connect({{trans.name}}_echo_sub.analysis_export);
                {{trans.name}}_echo_sub.mon_handle = {{trans.name}}_agent.{{trans.name}}_xmon;
            end
        end
{% endfor -%}
{% endif -%}
    endfunction

    virtual task main_phase(uvm_phase phase);
        phase.raise_objection(this);
        // Wait for Python to send transactions
        // Python controls simulation time via Step() calls
        #100000;
        phase.drop_objection(this);
    endtask

endclass

// =============================================================================
// Test
// =============================================================================

class example_test extends uvm_test;
    `uvm_component_utils(example_test)
    example_env env;

    function new (string name = "example_test", uvm_component parent = null);
        super.new(name, parent);
    endfunction

    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        env = example_env::type_id::create("example_env", this);
    endfunction

    virtual task main_phase(uvm_phase phase);
        phase.raise_objection(this);
{% if generate_dut -%}
        `uvm_info("example_test", "UVM test started with DUT, waiting for Python to drive transactions...", UVM_LOW)
{% else -%}
        `uvm_info("example_test", "UVM test started in echo-back mode, waiting for Python...", UVM_LOW)
{% endif -%}
        #100000;
        phase.drop_objection(this);
    endtask
endclass

// =============================================================================
// Top Module
// =============================================================================

module sv_main;
    logic clk;
    logic rst_n;

{% if generate_dut -%}
    // DUT mode: create DUT interface
    dut_interface dif(clk, rst_n);

{% if trans.from_rtl -%}
    // Instantiate DUT (auto-generated from RTL)
    {{module_name}} dut (
{% for var in variables -%}
        .{{var.name}}(dif.{{var.name}}){% if loop.index < length(variables) %},{% endif %}
{% endfor %}
    );
{% else -%}
    // TODO: Instantiate your DUT module here and connect to dif interface
    // Example:
    // YourDUT dut (
    //     .clk(clk),
    //     .rst_n(rst_n),
    //     .a(dif.a),
    //     .b(dif.b)
    //     // ... connect all signals from dut_interface
    // );
{% endif -%}
{% else -%}
    // Echo-back mode: minimal interface
    example_interface vif(clk, rst_n);
{% endif -%}

    // Clock generation
    initial begin
        clk = 0;
        forever #2 clk = ~clk;
    end

    // Reset generation
    initial begin
        rst_n = 1'b0;
        #10 rst_n = 1'b1;
    end

    initial begin
        // Set virtual interface in config_db
{% if generate_dut -%}
        uvm_config_db#(virtual dut_interface)::set(null, "*", "vif", dif);
{% else -%}
        uvm_config_db#(virtual example_interface)::set(null, "*", "vif", vif);
{% endif -%}

        // Run test
        run_test("example_test");
    end
endmodule
